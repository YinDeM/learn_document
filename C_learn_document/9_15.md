#### 9_15

##### 第5章 指针与数组，指针的作用避免副本和共享数据，重要功能是函数之间传递参数
1. 指针是能够存放一个地址的一组存储单元（通常是2或4字节）。
2. &取地址符，只能用于内存中的对象，即变量和数组元素，不能用于表达式、常量或register类型的变量
3. p = &c;      把c的地址赋值给p，称p为指向c的指针
4. 一元运算符：* 是间接寻址或间接引用的运算符，作用于指针时将访问指针所指向的对象。
5. 指针的声明：int *ip;     该声明语句表明表达式 *ip是int类型。。也就是表示指针指向的对象是int类型，ip是指向int类型的指针
6. 指针只能指向某种特定类型的对象，每个指针都必须指向某种特定的数据类型（除了void类型指针）
7. 指针ip = &x;     表示ip指向x。也就是说*ip = x;
8. 指针也是变量，所以可以在程序中直接使用，例如可以赋值
9. C中是传值的方式调用函数，所以如果需要改变主调函数中的值，需要使用指针。
    例：交换两个数的次序，调用函数：`swap(&a, &b);`
    ```c
    void swap(int *px, int *py){
        int temp;

        temp = *px;
        *px = *py;
        *py = temp;
    }
    ```
10. 使用指针传递输出结果（函数处理后的结果）
11. 用指针执行的操作比数组执行速度快，通过数组下标能完成的任何操作都可以通过指针来实现。
    int *pa;
    pa = &a[0];
    则pa是指向a数组第0个元素的指针。*pa = a[0]; *(pa + 1) = a[1]; *(pa + i) = a[i]
    数组类型变量或表达式的值是该数组第0个元素的地址。所以pa = &a[0];相当于pa = a;。因为数组名所代表的就是该数组最开始的一个元素的地址。a[i]可以写成*(a+i)
    一个通过数组和下标实现的表达式可以等价的通过指针和偏移量实现。
    注意：数组名和指针的不同：指针是一个变量，但是数组名不是。指针可以进行运算操作，数组名不可以
12. char s[];   和   char *s;   是等价的
13. 指针运算：p++,p+=i
    C语言的地址运算方法是一致而且有规律的，将指针、数组和地址的算术运算集成在一起。
14. C语言保证0永远不是有效的数据地址，因此返回0可用来代表发生了异常事件。
15. 指针和整数之间不能相互转换，除了0。
16. 指针之间的比较运算：当两个指针指向的是一个数组的成员时，就可以进行运算并且有意义。前边的数组元素指针小于后边的。
17. 指针的加法和减法：p+n：n将根据p指向的对象的长度进行按比例缩放，例如如果p指向的是int型占4字节，则在int类型中，n将按照4的倍数来计算。
18. 有效的指针运算：
    - 相同类型指针之间的赋值运算
    - 指针和整数之间的加减法运算
    - 指向相同数组中元素的两个指针间的减法或比较运算
    - 将指针赋值为0或指针与0之间的比较运算
    其他的指针运算都是非法的
19. 字符串常量是一个字符数组，以\0结尾。访问以字符指针的形式访问。
    char *pmessage;
    pmessage = "now is the time";
    这个过程只是将指向该字符数组的指针赋值给 pmessage。过程中不涉及字符串的复制。
    char amessage[] = "now is the time";//数组，写死的amessage始终指向数组的第一个元素，但是数组中的单个字符可以修改
    char *pmessage = "now is the time";//指针，初值指向一个字符串常量，之后可以随意修改，但是修改字符串的内容是没有定义的
20. 指针也是一个变量，也可以存放在数组中。指针数组声明：char *p[MAXSIZE];
21. 指针数组的初始化：数组的元素是字符数组的第一个元素的指针
    ```c
    char *month_name(int n){
        static char *name[] = {
            "Illegal month", "January", "February"
        };
    }
    ```
22. 多维数组：a[][] = {};   二维数组是一种特殊的一维数组，它的每一个元素都是一个一维数组。
23. 命令行参数：在支持C语言的环境中，可以在程序开始执行时将命令行的参数传给程序。main函数有两个参数，第一个argc 用于参数计数，表示运行程序时命令行中参数的数目。第二个argv 用于参数向量，是一个指向字符串数组的指针，每个字符串对应一个参数。
    C语言约定argv[0]的值是 启动该程序的程序名，argc至少为1。第一个可选参数是argv[1]，最后一个可选参数是argv[argc-1]。标准要求argv[argc]的值必须为一空指针
24. 指向函数的指针：函数的地址（存放函数代码的地址）
    int (*comp)(void *, void *);    表明comp是一个指向函数的指针，有两个 void *类型的参数，返回值是int
25. 复杂声明

##### 第6章 结构
1. 结构体是一个或多个变量的集合。
2. struct关键字引入结构体声明
    struct name {
        int x;
        int y;
    };
    结构体中的变量称为成员
    定义结构体变量：struct point pt;
    给结构体变量赋值：struct point pt = {12, 21};
    访问结构体中的成员：pt.x pt.y
    结构体可以嵌套
3. 结构与函数：
    结构体的合法操作：作为一个整体复制和赋值，通过&取地址，访问其成员
    结构体可以作为一个特别的数据类型看待，可以作为返回值。
    结构体指针类似于普通变量指针，声明：struct point *pp;*的优先级低，所以要加圆括号
    C语言引入一种简写形式：pp->x等同于(*pp).x
    ```c
    struct point origin, *pp;
    pp = &origin;
    printf("origin is (%d,%d)\n", (*pp).x, (*pp).y);
    ```
4. 下边两种形式的结构体声明相同，都会声明一个结构类型key并定义了一个该类型的结构数组keytab，同时为其分配了存储空间。
```c
struct key {
    char *word;
    int count;
} keytab[NKEYS];
```
```c
struct key {
    char *word;
    int count;
};
struct key keytab[NKEYS];
```
5. 编译时一元运算符：sizeof()，可以计算任意对象的长度
6. 自引用结构，在结构体中声明自己的结构体指针
7. 类型定义：typedef，可以建立新的数据类型名，类似重命名，定义后的类型与原类型完全相同。
8. 联合：一个变量可以合法的保存多种数据类型中任何一种类型的对象，可以嵌套，可以用在结构体和数组中
9. 位字段：
    struct {
        unsigned int is_keyword : 1;
        unsigned int is_extern : 1;
        unsigned int is_static : 1;
    }flafs;
    //这里定义一个变量flags,它包含3个1位的字段,冒号后的数字表示字段的宽度(用二进制位数表示),字段被声明为unsigned int,以保证它们的无符号量.
    flags.is_extern = flags.is_static = 1;//置1
    flags.is_extern = flags.is_static = 0;//置0

10. source_table_t是结构体的别名，可以直接用这个别名来声明结构体
```c
typedef struct {
    uint32_t source_id;
    uint32_t source_type;
    uint32_t source_volume_type;
    uint32_t device_id;
    uint32_t volume;
} source_table_t;
```